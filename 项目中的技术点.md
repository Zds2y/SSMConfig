### Redis和Mongodb：

就Redis和MongoDB来说，大家一般称之为**Redis缓存、MongoDB数据库**。这也是有道有理有根据的，

**Redis**主要把数据存储在内存中，其“**缓存**”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；

**MongoDB**却是一个“**存储数据**”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。

#### Mongodb的持久化方式：

MongoDB 的所有数据实际上是存放在硬盘的，所有要操作的数据通过 mmap(内存文件映射) 的方式映射到内存某个区域内。
然后，MongoDB 就在这块区域里面进行数据修改，避免了零碎的硬盘操作。
至于 mmap上的内容flush到硬盘就是操作系统的事情了，所以，如果，MongoDB 在内存中修改了数据后，mmap 数据flush到硬盘之前，系统宕机了，数据就会丢失。

#### redis的使用场景：

1、对于执行时间较长且执行结果长时间不变的sql，放到redis缓存中

![img](https://img-blog.csdn.net/20180614162041997?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hjbW9ueQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2、在高并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

![img](https://img-blog.csdn.net/20180614162101553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hjbW9ueQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 使用redis有什么缺点：

主要是以下四个问题：

(一)缓存和数据库双写一致性问题

(二)缓存雪崩问题

(三)缓存击穿问题

(四)缓存穿透问题

(五)缓存的并发竞争问题

#### redis是单线程的为什么会那么快：

1、纯内存操作

2、单线程操作，避免了频繁的上下文切换

3、采用了非阻塞IO多路复用机制

#### redis中的数据类型，和适用场景：

1、String  存储基本类型数据时使用

2、Hash  存储对象的时候使用

3、List 	当作消息队列

4、Set     可以做全局去重的功能，就是利用交集、并集、差集等操作，可以计算共同喜好，全				 部的喜好，自己独有的喜好等功能

5、SortedSet(ZSet): 可以做排行榜应用，取TOP N操作

#### redis的过期策略以及内存淘汰机制

假设当前你的redis中只能存5G的数据，但是你已经向redis中存储了10G数据，那么另外5G数据是怎么删除的？你的数据已经设置了过期时间，但是过期时间到了，内存占用还是比较高，是什么原因导致的？

**redis采用的是定期删除+惰性删除策略。**

**为什么不用定时删除策略?**
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在高并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.
**定期删除+惰性删除是如何工作的呢?**
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
**采用定期删除+惰性删除就没其他问题了么?**
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

在redis.conf中有一行配置

```xml
# maxmemory-policy volatile-lru
```

该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)
1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
**2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。**
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

#### redis和数据库双写一致性问题

分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。
回答:《分布式之数据库和缓存双写一致性方案解析》给出了详细的分析，在这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

### nginx的特性：

1、虚拟服务器

2、反向代理

场景：前台发送一个请求   后台有三台tomcat服务器 

​	当用户请求服务器时，nginx服务器在此时充当代理服务器，用户不需要关注要请求哪一台tomcat服务器，由nginx代理后台服务器，nginx会去访问配置文件中配置的那台服务器。

3、负载均衡（使用的也是反向代理）

场景：前台有500个请求，后台有三台tomcat服务器

​	前台有500个请求并发请求过来了，如果此时没有使用nginx来进行负载均衡，可能500个请求同时访问了同一个tomcat服务器，会导致服务器的宕机。这时使用nginx服务器来提供负载均衡服务，ningx服务器会将请求分发给每个服务器。需要在nginx配置文件中同时配置三个tomcat服务器，还可以设置每个tomcat服务器的权重，权重越高，被请求的几率越大。

### json对象的格式，json字符串的格式，js对象的格式：

### SpringBoot：

### JDK1.8新特性：

1、Optional对象

### 定时任务框架：

1、Quartz 框架

2、SpringTask 是对Quart 框架的进一步封装，使开发更加方便

### Vue.JS的使用：

### Spring Cloud：

#### 什么是微服务：

