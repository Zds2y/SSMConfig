## Ajax的实现流程

**实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:**

​       1、**创建XMLHttpRequest对象,也就是创建一个异步调用对象.**

​       2、**创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.**

​       3、**设置响应HTTP请求状态变化的函数.**

​       4、**发送HTTP请求.**

​       5、**获取异步调用返回的数据.**

​       6、**使用JavaScript和DOM实现局部刷新.**

 

## Redis缓存

redis速度快的原因：

redis是单线程的  避免了IO的阻塞和等待

redis底部使用的是 异步非阻塞IO

### **什么是redis缓存：**

​		1、redis是一种非关系型数据库，就是键值对数据库

​		2、支持五种数据类型，String(字符串)，Hash(key-value格式)，List(列表)，Set(集合)，Zset(Sorted Set有序				集合 )

​		3、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？

​		持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。

​		Redis 提供了两种持久化方式:RDB（默认） 和AOF 

​		RDB方式：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。

​							类似于快照的模式，每隔一段时间，将当前的数据进行快照备份

​		AOF方式：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启						   的时候，可以通过回放AOF 日志中的写入指令来重新构建整个数据集。

​							类似于日志的模式，每次执行操作时，就会更新aof文件，来实现持久化的功能

​		优缺点：

**RDB 优缺点**

- RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis
  的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3云服务上去，在国内可以是阿里云的 ODPS 分布式存储	上，以预定好的备份策略来定期备份redis中的数据。
- RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork
  一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。
- 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。
- 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。
- RDB 每次在 fork 子进程来执行 RDB
  快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

**AOF 优缺点**

- AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。
- AOF 日志文件以 append-only
  模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。
- AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log
  的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge
  后的日志文件 ready 的时候，再交换新老日志文件即可。
- AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall
  命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall
  命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。
- 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。
- AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync
  一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）
- 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge的，而是**基于当时内存中的数据进行指令的重新构建**，这样健壮性会好很多。

### redis的事务：

​		https://www.cnblogs.com/DeepInThought/p/10720132.html

### **什么是缓存穿透：**

​		当有人请求的数据，在缓存中一定不存在，那么就会去数据库中查询，但是数据库中也不存在，这时就会返回一个空对象，那么缓存中还是没有该数据，那么如果同时有大量的这种请求过来，那么都会直接去访问数据库，会导致数据库垮掉，进而导致服务器崩掉。

​		解决方案（两种）：

​		1、由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！

​		2、当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。

### **什么是缓存雪崩：**

​		我们的缓存都设置的有过期时间，如果我们将过期时间都设在同一时间，可能在那一时间缓存同时过期，这时候也恰巧有高并发的访问，所有的请求都会直接去访问数据库，就会导致数据库垮掉，进而导致整个服务器崩掉。

​		解决方案：

​		可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效

### **什么是缓存击穿：**

​		当缓存中某一热点key过期了，但同时有大量的请求访问这个key，在缓存中找不到，就会去找数据库，会导致数据库垮掉，进而导致服务器崩掉。

​		解决方案：

​		

## 全文检索技术

### solr：

底层基于lucene的全文检索技术

在使用前需要先建立索引库

建立索引库的流程：获取原始文档，创建文档对象--》对原始文档进行分词--》建立索引

solr是一个实时搜索

### ElaticSearch：

ElaticSearch是一个延时搜索(延时是相对的)

### 对比

- solr和Elasticsearch的区别：
  - Solr建立索引时候，搜索效率下降，实时搜索效率不高，es实时搜索效率高
  - Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能。
  - Solr支持更多格式的数据，比如JSON、XML、CSV，而Elasticsearch仅支持json文件格式。
  - Solr官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供
  - Solr在传统的搜索应用中表现好于Elasticsearch，但在处理实时搜索应用时效率明显低于Elasticsearch。
  - Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。
  - Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；
  - Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。

- 补充说明：
  - Solr有一个更大、更成熟的用户、开发和贡献者社区
  - Solr支持多种数据格式的索引，比如：JSON、XML、CSV等多种数据格式
  - Solr搜索海量历史数据，速度非常快，毫秒级返回数据
  - es支持分布式，节点对外表现对等，加入节点自动均衡
  - es完全支持Apache Lucene的接近实时的搜索
  - es处理多租户multitenancy不需要特殊配置，而Solr需要更多的高级设置
  - es采用Gateway的概念，使得数据持久化更简单
  - es各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作
- 使用方式：
  - solr一般要部署到web服务器上，比如tomcat，启动tomcat，配置solr和tomcat的关联
  - es一般可以单独启动，然后es和spring整合，调用SpringDataElasticSearch里面提供的方法

## dubbo：

dubbo有哪些通信协议：

dubbo有哪些序列化协议：

## Webflux：

## 网页静态化技术（freemarker）:

### 介绍：

用于减小数据库的访问压力，可以使用缓存技术和网页静态化技术

缓存技术比较适用于较小规模的数据

网页静态化就适用于较大规模的数据，且变动不太频繁的数据

网页静态化比较适用于SEO(搜索引擎优化)技术

网页静态化后就可以部署在nginx服务器上，nginx比tomcat性能高很多，可以支持更多的并发量

逆向工程的模板也可以使用freemarker来生成

freemarker不仅仅只是用来做网页静态化，freemarker是一个模板引擎，可以用来生成很多模板

freemarker最常用的就是用来做网页静态化 

### 指令：

### 内建函数：

### 逻辑运算符：

## 文件服务器：

### fastDFS:

分布式文件服务器

### 七牛云：

将文件交给第三方公司进行管理

## 消息解决方案

降低模块与模块之间的耦合性

解决模块间异步调用的问题

### 消息中间件

使用场景：执行时间长，不需要返回值的服务，就可以使用消息中间件

### ActiveMQ

发送消息的类型：

​	1、TextMessage：字符串文本消息

​	2、MapMessage：map类型消息

​	3、ObjectMessage：**可序列化对象**类型的消息

​	4、BytesMessage：字节类型的消息，多用于传输视频，音乐等数据

​	5、StreamMessage：流类型的消息

发送消息的两种类型：

​	1、点对点模式：一条消息只能由一个消费者接收，可以延时接收消息。就算发消息的时候，没有接收，当消费者启动时，还是能接收到这条消息。

​	2、发布/订阅模式：一条消息可以由多个消费者接收，必须实时接收消息，过时不候。类似于广播，在发布消息的时候没接收到，后面就不能再接收到了。

### dubbo和消息中间件的区别：

dubbo解决的是分布式模块之间的调用问题，其实还是同步调用  通过RPC协议。能拿到方法的调用者执行后的结果。

消息中间件解决的是模块间异步调用的问题，是异步调用。消息的生产者拿不到消费者执行后的结果

## SSO(单点登录解决方案)

### CAS：单点登录的一个具体解决技术

### 为什么使用CAS和SpringSecurity来结合使用？

​	1、因为使用原生的CAS，所有的配置都写在web.xml文件中，这样不是很好。

​	2、结合了之后，CAS的配置都会写在SpringSecurity的配置文件中，而且SpringSecurity和CAS结合之后，在配置文件中有专门配置CAS的标签。

​	3、CAS验证中心只能验证用户名和密码以及票据是否正确，不能验证用户的权限，而和SpringSecurity结合之后，两者共同协作，CAS验证用户名密码以及票据，SpringSecurity验证用户的权限。



## 单例模式怎么实现？

## 跨域请求解决方案：

只要协议、主机(IP地址)/域名、端口有任何一个不同，都被当作是不同的域。

### 跨域请求问题出现场景：

这里说的 js 跨域是指通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据

**只有在前端页面上请求数据，才会出现跨域请求问题，在后端服务器之间进行数据的请求不算是跨域**

### 解决方案：

1、服务器代理解决方案：就是将跨域请求不放在前端页面进行，而是放在服务器上进行跨域请求数据，服务器再将请求到的数据发送给前端页面。

![1568978132282](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1568978132282.png)

2、jsonP

3、CORS：目前用的比较多，但技术比较新，有的公司用的技术可能比较老，就只能使用前两种方法解决跨域请求问题。

**通过在被请求的方法中设置请求头中的属性值来解决跨域请求问题**

![1568978940126](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1568978940126.png)

```java
设置信任的域：response.setHeader("Access-Control-Allow-Origin", "需要信任的域"); 
						比如http://localhost:9106	可以使用*代替，表示信任所有的域
是否开启cookie跨域：response.setHeader("Access-Control-Allow-Credentials", "true"); 
```

![1568978579768](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1568978579768.png)

CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。另一方面，开发者必须在 AJAX 请求中打开 withCredentials 属性。否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理

**在springMVC4.2版本后，spring中新增了跨域请求注解 @CrossOrigin**

只需要在跨域的方法上加上这个注解，并配置信任的域就行了，默认是开启cookie跨域的

![1568979007693](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1568979007693.png)



## 电商项目的购物车模块

**添加购物车的逻辑：**

未登录情况下，将购物车列表存到cookie中，只在本机有效。

登录情况下，将购物车列表存到redis中，可以在各地有效。

**1、未登录情况下：**

​		①用户点击加入购物车后，将该商品的skuId和商品的数量发送给后台，后台在添加之前查询一下cookie中的购物车列表，将购物车列表，以及skuId和商品数量一起发送给服务层。

​		②服务层拿到数据后，

​				（1）先拿着skuId去数据库中查询，判断查询出来的sku对象是否为空，如果为空，那表示选中添加的商品就有问题，那么直接抛出异常；

​				（2）如果sku对象不为空，再判断sku对象的状态是否为可用，如果不可用抛出异常

​		③取出商品的商家ID，遍历购物车列表，判断购物车列表中是否已经存在该商家的购物车对象

​				（1）如果不存在与添加的商品同一个商家，那么创建一个新的购物车对象，并将值sku对象中的值赋给该购物车对象中的商品详情对象。

​				（2）如果存在与添加的商品同一个商家，再拿着skuId，去商品详情列表中查询是否有相同的商品。

如果有相同的商品，那么将该商品的数量加上前端传来的数量，然后总金额重新合计；

如果没有相同的商品，那么新建一个商品详情对象，将该有的值赋给这个商品详情对象，再将这个商品详情对象添加到商品详情列表中。 

**2、登录情况下：**

​		①先查询cookie中是否有购物车列表数据，如果有，那么将cookie中的购物车列表和redis中的购物车列表进行合并，合并规则和添加购物车列表相似，循环两个购物车列表中的一个，拿着循环的购物车列表中的商品详情对象数据，去另一个购物车列表中判断，如果商家没有相同的，那么将新建一个商家购物车对象，如果有相同的，那么就去判断购物车列表中的商品详情对象是否相同，不同则创建新的商品详情对象，有相同的那么就数量和总金额重新赋值。

​		②在合并购物车之后，将合并后的购物车存到redis中，并清空cookie中的数据。

​		③再向合并后的购物车列表中添加选中的商品数据，跟未登录时的流程一致。

## 电商项目订单的生成：

必会：java基础，javaweb基础，ssm框架，redis以及常用的缓存技术

加分点：cas，mq，搜索

## 支付模块：

### 微信支付：

使用了微信提供的支付接口

微信支付流程：

① 用户点击生成订单，会在后台生成一个订单， 后台调用一下微信提供的下单API，从微信支付系统中获取生成的预支付链接(url)。

② 后台将获取到的预支付链接发送给前台，前台使用这个链接生成一个二维码。

③ 用户使用微信扫描二维码，其实就是访问二维码中的预支付链接，微信支付系统验证二维码中url的有效性，如果有效，就会向用户显示微信的支付页面，页面上能看到订单号和需要支付的金额。用户完成付款后，只能看到在微信支付系统上已支付(短信，微信消息告知)，但是并看不到购物网站支付后的效果(页面跳转到支付成功页面)。这时就需要后台进行判断。

④ 后台有两种方式可以获取该订单的支付情况

​		（1）当用户完成支付后，微信支付系统主动向后台发送用户的支付情况(在开发时，这种方式无效，因为在开发时，服务器是本地服务器，外网无法访问，只有在项目上线部署到公网上时，这个才有用处。)

​		（2）后台调用查询订单API，向微信支付系统发送查询请求，去查询用户的支付情况

​			一般在实际开发中会两种结合一起使用，再加定时任务去定时(一个小时左右)的扫描数据库中订单支付情况和支付日志中支付情况和微信支付系统中的用户支付情况进行比对，然后同步数据，以微信支付系统的支付情况为准，同步数据库中的数据，这样基本就能保证支付的同步性，极大的减少了，用户已支付但订单状态为未支付。

细节：

① 后台要持续的向微信支付系统发送查询请求，去查询用户的支付情况，因为后台并不知到用户何时完成了支付操作。但是查询请求又不能太频繁，可以设置没发一次请求，睡眠3秒，再发第二次请求去查询支付情况。如果发送请求的次数到达100次，就是300s(5分钟)后，用户还未支付，那么向前台发送消息“二维码过期”，然后重新生成二维码。

### 支付宝支付：

使用支付宝提供的支付接口

支付宝支付流程：



## 秒杀模块：

① 在实际中，秒杀系统和其他系统是完全分离的，防止当秒杀系统宕机后，不会影响到其余系统的使用

秒杀系统因为高并发，很容易出问题

② 秒杀的首页可以使用网页静态化技术，将大部分数据直接放在静态页面上，将小部分需要变化的数据，放在redis中，可以减少数据的传输量，提高响应速度。

③ 设置一个定时任务，在秒杀开始前将参与秒杀的商品数据存到redis中，因为如果在秒杀开始时再将数据放入缓存中，这个并发太高，还是会将数据库打垮。

### 电商秒杀中的问题：

① 

## hibernate和mybatis的区别：

## SpringDate JPA：

### lombok注解：

1、导入依赖

2、在idea中安装lombok插件

3、使用注解

​		@Data  可以在使用在实体类中，不用写getter和setter和toString方法，在编译时自动生成

​		@NoArgsConstructor  使用在实体类上，在编译时自动生成无参构造

​		@AllArgsConstructor  使用在实体类上，在编译时自动生成全参构造



### 查询数据库，如果被查询的数据不存在会返回什么？

**在jpa中**

​	 使用find()方法进行查询，如果查询的数据不存在那么会返回一个null

​	 使用getReference()方法进行查询，如果查询的数据不存在那么会抛出异常

**在mbatis中**

​	  如果查询的数据不存在那么会返回一个

### JPA中find方法和getReference的区别：

find方法和getReference的区别：

find方法：立即加载，查询出来的结果是对象本身，不管你用不用查询出来的对象，都会去数据库中进行查询

getReference方法：延迟加载(懒加载)，查询出来的结果是一个动态代理对象，执行查询的时机是在你使用这个对象的属性时，才会去数据库查询数据，意思就是你什么时候用，就什么时候查。

1、find()当查询的数据在数据库中不存在时，会返回null

​	  getReference()当查询的数据在数据库中不存在时，会直接抛出异常

2、find()查询出来的是参数中的对象本身

​      getReference()查询出来的是参数中的对象的代理对象，而且使用的是cglib代理，基于继承的代理，如果实体类被final修饰了，那么就无法使用动态代理了，延迟加载会失效，就和find是一样了

3、find()是立即加载，当执行查询方法的时候，就会去数据库中将数据查询出来

​	  getReference()是延迟加载(懒加载)，只有当使用到查询的对象时，才会去数据库中查询数据

4、如果想要优化，那么使用getReference()进行延迟加载，使用的时候才会去数据库中查询数据，可以减轻数据库的压力。

### jpql(java持久化查询语言)：

## 单例模式：

**饿汉单例模式：**

```java
/**
 * 饿汉单例模式
 */
class Singleton{

    //私有化成员变量  直接创建出Singleton对象  你想用直接拿就行了
    private static final Singleton singleton=new Singleton();

    //私有化构造方法
    private Singleton(){}

    //创建一个静态方法获取对象
    public static Singleton getInstance(){
        return singleton;
    }
}
```

**懒汉单例模式：**

```java
/**
 * 懒汉单例模式  要使用双重检测锁才能保证对象的唯一
 */
class Singleton{

    //私有化成员变量  先不给成员变量赋值 等到有人使用的时候再创建，不用就不创建
    private static Singleton singleton=null;

    //私有化构造方法
    private Singleton(){}

    //创建一个静态方法获取对象  懒汉单例模式会出现没有单例的问题 这时候要使用双重检测锁
    public static Singleton getInstance(){
        //这样主要因为程序执行需要时间 这里进行双重判断就不会出现创建了两个对象
        //先判断singleton对象是否为空
        if (singleton==null){ // 可能 线程1 线程2 同时执行到了这里 都通过了判断为空
            //使用同步锁
            synchronized ("0"){
                //再次判断singleton对象是否为空 如果为空才创建对象
                if (singleton == null){
                    singleton=new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

